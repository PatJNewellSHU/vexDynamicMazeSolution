{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:      Patrick Newell\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\ndef main():\n    #solveMaze()\n    #drivetrain.turn_for(RIGHT, 90, DEGREES)\n    #returnBack()\n\n    mapMaze()\n    \n\n    \n\n\n    \n\n# VR threads â€” Do not delete\nvr_thread(main)\n\ndef mapMaze():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    nodeList = []\n\n\n    \n    #starting postion based on top left conrer being 0,0\n    xCor = 4\n    yCor = 7\n    pen.set_pen_width(WIDE)\n    pen.set_pen_color(BLACK)\n    pen.move(DOWN)\n\n    while not down_eye.detect(RED):\n        if front_distance.get_distance(MM) > 2000 and ((xCor == 4 or xCor == 3) and(yCor == 0 or yCor == 7)):\n            drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n\n\n        nodeLogged = False\n        up = 0\n        down = 0\n        left = 0\n        right = 0\n\n        # chekc if node exists\n        #if it doesnt it will then rotate around the current node to see where it has walls\n        #then it will create a new node with current coords and append them to the nodelist\n        for n in nodeList:\n            if n['x'] == xCor and n['y'] == yCor:\n                nodeLogged = True \n        if nodeLogged == False:\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                up = 1 \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                right = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                down = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                left = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            newNode = createNode(xCor,yCor,up,down,left,right)\n            nodeList.append(newNode)\n            brain.print(newNode)\n            brain.new_line()\n            brain.print(nodeList)\n            \n\n        if front_distance.get_distance(MM) > 260:\n\n            drivetrain.drive_for(FORWARD, 250, MM)\n            #change chords based on what movenets performed\n            if drivetrain.heading(DEGREES) == 0:\n                yCor -= 1\n            \n            elif drivetrain.heading(DEGREES) == 90:\n                xCor += 1\n\n            elif drivetrain.heading(DEGREES) == 180:\n                yCor += 1\n\n            elif drivetrain.heading(DEGREES) == 270:\n                xCor -= 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        \n\n    \n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n    pen.set_pen_color(RED)\n    pen.set_pen_width(EXTRA_THIN)\n    pen.move(DOWN)\n    while not (yCor == 7 and xCor == 4):\n        if front_distance.get_distance(MM) > 2000 and ((xCor == 4 or xCor == 3) and(yCor == 0 or yCor == 7)):\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        nodeLogged = False\n        up = 0\n        down = 0\n        left = 0\n        right = 0\n\n        # chekc if node exists\n        #if it doesnt it will then rotate around the current node to see where it has walls\n        #then it will create a new node with current coords and append them to the nodelist\n\n        for n in nodeList:\n            if n['x'] == xCor and n['y'] == yCor:\n                nodeLogged = True \n        if nodeLogged == False:\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                up = 1 \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                right = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                down = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                left = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            newNode = createNode(xCor,yCor,up,down,left,right)\n            nodeList.append(newNode)\n            brain.print(newNode)\n            brain.new_line()\n            brain.print(nodeList)\n\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM)\n            if drivetrain.heading(DEGREES) == 0:\n                yCor -= 1\n            \n            elif drivetrain.heading(DEGREES) == 90:\n                xCor += 1\n\n            elif drivetrain.heading(DEGREES) == 180:\n                yCor += 1\n\n            elif drivetrain.heading(DEGREES) == 270:\n                xCor -= 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n    while not down_eye.detect(RED):\n        if front_distance.get_distance(MM) > 2000 and ((xCor == 4 or xCor == 3) and(yCor == 0 or yCor == 7)):\n            drivetrain.turn_for(RIGHT, 180, DEGREES)\n        nodeLogged = False\n        up = 0\n        down = 0\n        left = 0\n        right = 0\n\n        # chekc if node exists\n        #if it doesnt it will then rotate around the current node to see where it has walls\n        #then it will create a new node with current coords and append them to the nodelist\n        for n in nodeList:\n            if n['x'] == xCor and n['y'] == yCor:\n                nodeLogged = True \n\n        if nodeLogged == False:\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                up = 1 \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                right = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                down = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            if front_distance.get_distance(MM) < 260:\n                left = 1\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            brain.print(front_distance.get_distance(MM))\n            brain.new_line()\n            newNode = createNode(xCor,yCor,up,down,left,right)\n            nodeList.append(newNode)\n            brain.print(newNode)\n            brain.new_line()\n            brain.print(nodeList)\n\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM)\n            if drivetrain.heading(DEGREES) == 0:\n                yCor -= 1\n            \n            elif drivetrain.heading(DEGREES) == 90:\n                xCor += 1\n\n            elif drivetrain.heading(DEGREES) == 180:\n                yCor += 1\n\n            elif drivetrain.heading(DEGREES) == 270:\n                xCor -= 1\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n\n    drawMaze(nodeList)\n        \n\n\ndef solveMaze():\n    #this is now redudnant\n    pen.set_pen_width(WIDE)\n\n    drivetrain.set_drive_velocity(100, PERCENT)\n    pen.set_pen_color(BLACK)\n    pen.move(DOWN)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    while not down_eye.detect(RED):\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n\ndef returnBack():\n    #this is now redudnant\n    drivetrain.set_drive_velocity(100, PERCENT)\n    pen.set_pen_color(RED)\n    pen.set_pen_width(EXTRA_THIN)\n    pen.move(DOWN)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    while front_distance.get_distance(MM) < 2000:\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n            \ndef createNode(x,y,up,down,left,right):\n    node = {\n        \"x\":x,\n        \"y\":y,\n        \"vertices\": [up,down,left,right]\n    }\n    return node\ndef drawMaze(nodes):\n    brain.print(nodes)\n    brain.new_line()\n    #maze drawing function\n    #im sorry this is so ugly\n    #pick out  0,0 from list of nodes then draw out all up walls from that row then right and left then down \n    #then once thats done go to next row and repeat \n    #+++++ 1,1,1,1\n    #+   +\n    #+   +\n    #+++++\n\n    #+++++ 1,1,0,0\n    #\n    #\n    #+++++\n\n    #+   + 0,1,1,1\n    #+   +\n    #+   +\n    #+++++\n\n    #+++++ 1,1,1,0\n    #+\n    #+\n    #+++++\n\n    #+   + 0,0,1,1\n    #+   +\n    #+   +\n    #+   +\n\n    #+++++ 1,0,0,0\n    #\n    #\n    #+   +\n\n    #+   + 0,1,0,0\n    #\n    #\n    #+++++\n\n    #+   + 0,0,1,0 7\n    #+\n    #+\n    #+   +\n\n    #+   + 0,0,0,1 8\n    #    +\n    #    +\n    #+   +\n\n    #+++++ 1,0,1,1 9\n    #+   +\n    #+   +\n    #+   +\n\n    #+++++ 1,0,0,1 10\n    #    +\n    #    +\n    #+   +\n\n    #+++++ 1,0,1,0 11\n    #+   \n    #+\n    #+   +\n\n    #+   + 0,1,1,0 \n    #+\n    #+\n    #+++++\n\n    #+   + 0,1,0,1\n    #    +\n    #    +\n    #+++++\n\n    #+   + 0,0,0,0\n    #\n    #\n    #+   +\n\n    #+++++ 1,1,0,1\n    #    +\n    #    +\n    #+++++\n\n\n\n\n    maze = []\n\n    x = 0\n    y = 0\n    for i in range(0,64):\n        for n in nodes:\n            if n['x'] == x and n['y'] == y:\n                edges = n['vertices']\n                #hell\n                if edges[0] == 1 and edges[1] == 1 and edges[2] == 1 and edges[3] == 1:\n                    block = \"+++++\\n+   +\\n+   +\\n+++++\"\n                    maze.append(block)\n\n                elif edges[0] == 1 and edges[1] == 1 and edges[2] == 0 and edges[3] == 0:\n                    block = \"+++++\\n\\n\\n+++++\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 1 and edges[2] == 1 and edges[3] == 1:\n                    block = \"+   +\\n+   +\\n+   +\\n+++++\"\n                    maze.append(block)\n\n\n                elif edges[0] == 1 and edges[1] == 1 and edges[2] == 1 and edges[3] == 0:\n                    block = \"+++++\\n+    \\n+    \\n+++++\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 0 and edges[2] == 1 and edges[3] == 1:\n                    block = \"+   +\\n+   +\\n+   +\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 1 and edges[1] == 0 and edges[2] == 0 and edges[3] == 0:\n                    block = \"+++++\\n\\n\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 1 and edges[2] == 0 and edges[3] == 0:\n                    block = \"+   +\\n\\n\\n+++++\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 0 and edges[2] == 0 and edges[3] == 1:\n                    block = \"+   +\\n    +\\n    +\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 1 and edges[1] == 0 and edges[2] == 1 and edges[3] == 1:\n                    block = \"+++++\\n+   +\\n+   +\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 1 and edges[1] == 0 and edges[2] == 0 and edges[3] == 1:\n                    block = \"+++++\\n    +\\n    +\\n+   +\"\n\n                elif edges[0] == 1 and edges[1] == 0 and edges[2] == 1 and edges[3] == 0:\n                    block = \"+++++\\n+    \\n+    \\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 1 and edges[2] == 1 and edges[3] == 0:\n                    block = \"+   +\\n+   +\\n+   +\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 1 and edges[2] == 0 and edges[3] == 1:\n                    block = \"+   +\\n    +\\n    +\\n+++++\"\n                    maze.append(block)\n\n                elif edges[0] == 0 and edges[1] == 0 and edges[2] == 0 and edges[3] == 0:\n                    block = \"+   +\\n\\n\\n+   +\"\n                    maze.append(block)\n\n                elif edges[0] == 1 and edges[1] == 1 and edges[2] == 0 and edges[3] == 1:\n                    block  = \"+++++\\n    +\\n    +\\n+++++\"\n                    \n        if x == 7:\n            x = 0\n            y += 1\n        x += 1\n    count = 0\n    for m in maze:\n        brain.print(m)\n        count += 1\n        if count == 7:\n            count = 0\n            brain.new_line()\n\n\n                \n\n\n\n   \n\n\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}